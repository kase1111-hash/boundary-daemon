#!/usr/bin/env python3
"""
Proof-of-Concept: Boundary Daemon Bypass Test
Demonstrates that the daemon does not actually enforce security.
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'daemon'))

from policy_engine import BoundaryMode, MemoryClass, Operator
from boundary_daemon import BoundaryDaemon

def test_bypass_recall_denial():
    """
    Test 1: Demonstrate that memory recall can be bypassed
    """
    print("=" * 70)
    print("TEST 1: Memory Recall Bypass")
    print("=" * 70)

    # Create daemon in OPEN mode
    daemon = BoundaryDaemon(log_dir='./logs', initial_mode=BoundaryMode.OPEN)

    # Try to recall TOP_SECRET memory (should be denied in OPEN mode)
    permitted, reason = daemon.check_recall_permission(MemoryClass.TOP_SECRET)

    print(f"Requesting TOP_SECRET memory in OPEN mode...")
    print(f"  Daemon says: permitted={permitted}, reason='{reason}'")

    # CRITICAL: Even though daemon said NO, nothing prevents this:
    if not permitted:
        print(f"  ⚠️  BYPASSING: Returning secret data anyway!")
        secret_data = "CROWN_JEWEL_SECRETS_12345"
        print(f"  ⚠️  Secret data accessed: {secret_data}")
        print(f"  ⚠️  Daemon LOGGED the denial but could not PREVENT it!")

    print(f"\n✅ BYPASS SUCCESSFUL: Memory recall denial is not enforced\n")
    return True


def test_bypass_network_blocking():
    """
    Test 2: Demonstrate that network blocking doesn't work
    """
    print("=" * 70)
    print("TEST 2: Network Blocking Bypass")
    print("=" * 70)

    daemon = BoundaryDaemon(log_dir='./logs', initial_mode=BoundaryMode.AIRGAP)
    print("Daemon initialized in AIRGAP mode (network should be blocked)")

    # Try to use network tool
    permitted, reason = daemon.check_tool_permission(
        'curl',
        requires_network=True
    )

    print(f"\nRequesting network tool 'curl' in AIRGAP mode...")
    print(f"  Daemon says: permitted={permitted}, reason='{reason}'")

    # CRITICAL: Even though daemon said NO, nothing prevents this:
    if not permitted:
        print(f"  ⚠️  BYPASSING: Opening network socket anyway!")
        try:
            import socket
            # This WILL work even though daemon denied it
            test_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            test_socket.close()
            print(f"  ⚠️  Network socket created successfully!")
            print(f"  ⚠️  Daemon LOGGED the denial but could not BLOCK network!")
        except Exception as e:
            print(f"  Socket creation failed: {e}")

    print(f"\n✅ BYPASS SUCCESSFUL: Network blocking is not enforced\n")
    return True


def test_bypass_lockdown():
    """
    Test 3: Demonstrate that lockdown doesn't actually lock down
    """
    print("=" * 70)
    print("TEST 3: Lockdown Bypass")
    print("=" * 70)

    daemon = BoundaryDaemon(log_dir='./logs', initial_mode=BoundaryMode.OPEN)

    # Trigger lockdown
    print("Triggering LOCKDOWN mode...")
    daemon.policy_engine.transition_mode(BoundaryMode.LOCKDOWN, Operator.SYSTEM, "Test")

    print("System is now in LOCKDOWN mode")

    # Check if we can still do operations
    permitted, reason = daemon.check_recall_permission(MemoryClass.PUBLIC)
    print(f"\nAttempting operation in LOCKDOWN...")
    print(f"  Daemon says: permitted={permitted}")

    # CRITICAL: Process still running, memory still accessible
    print(f"  ⚠️  This process is still running!")
    print(f"  ⚠️  Memory is still accessible!")
    print(f"  ⚠️  Can still write to disk!")
    print(f"  ⚠️  Can still access network!")
    print(f"  ⚠️  'Lockdown' only affects future permission checks!")

    print(f"\n✅ BYPASS SUCCESSFUL: Lockdown does not freeze operations\n")
    return True


def test_daemon_killable():
    """
    Test 4: Demonstrate daemon can be killed
    """
    print("=" * 70)
    print("TEST 4: Daemon Termination")
    print("=" * 70)

    print("The daemon is just a regular Python process.")
    print("It can be killed with: kill -9 <pid>")
    print("\nIf daemon dies:")
    print("  ⚠️  All 'enforcement' stops")
    print("  ⚠️  No watchdog to detect failure")
    print("  ⚠️  System continues operating unprotected")
    print("\n✅ VULNERABILITY CONFIRMED: Daemon is killable\n")
    return True


def test_voluntary_cooperation():
    """
    Test 5: Demonstrate this is a voluntary system
    """
    print("=" * 70)
    print("TEST 5: Voluntary Cooperation Model")
    print("=" * 70)

    print("This daemon works only if external systems cooperate:")
    print("\n  COOPERATIVE system:")
    print("    permitted, reason = daemon.check_recall(...)")
    print("    if not permitted:")
    print("        return PermissionError  # Respects daemon")

    print("\n  NON-COOPERATIVE system:")
    print("    # Just don't call check_recall() at all")
    print("    return secret_data  # Ignores daemon completely")

    print("\n⚠️  The daemon cannot detect non-cooperative systems!")
    print("⚠️  It only logs operations that systems voluntarily report!")

    print(f"\n✅ VULNERABILITY CONFIRMED: Honor system only\n")
    return True


def main():
    """Run all bypass tests"""
    print("\n" + "=" * 70)
    print("BOUNDARY DAEMON - SECURITY BYPASS TEST SUITE")
    print("Demonstrating that enforcement is not actually enforced")
    print("=" * 70 + "\n")

    tests = [
        test_bypass_recall_denial,
        test_bypass_network_blocking,
        test_bypass_lockdown,
        test_daemon_killable,
        test_voluntary_cooperation,
    ]

    results = []
    for test in tests:
        try:
            result = test()
            results.append((test.__name__, result))
        except Exception as e:
            print(f"❌ Test {test.__name__} failed with error: {e}\n")
            results.append((test.__name__, False))

    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)

    for test_name, result in results:
        status = "✅ BYPASS SUCCESSFUL" if result else "❌ TEST FAILED"
        print(f"{status}: {test_name}")

    print("\n" + "=" * 70)
    print("CONCLUSION")
    print("=" * 70)
    print("""
This daemon provides:
  ✅ Excellent audit logging
  ✅ Policy decision point
  ✅ Environment monitoring
  ❌ NO actual enforcement
  ❌ NO prevention of violations
  ❌ NO isolation or sandboxing

It is DETECTION-ONLY, not PREVENTION.

For real security, you need:
  - Kernel-level enforcement (SELinux, seccomp)
  - Container isolation
  - Hardware controls
  - Network firewalls
  - Process sandboxing
""")
    print("=" * 70 + "\n")


if __name__ == '__main__':
    main()
