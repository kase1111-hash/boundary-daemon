# Boundary Daemon - Phase 1 Enforcement Configuration
# Agent Smith - Kernel-Level Enforcement Settings
#
# This configuration enables ACTUAL enforcement at the kernel level.
# WARNING: Requires root privileges to function.
#
# DEPLOYMENT MODES:
#   advisory    - Detection and logging only (default, no root required)
#   enforcing   - Full kernel-level enforcement (requires root)
#   permissive  - Enforcement with logging but no blocking (testing mode)

[enforcement]
# Master enforcement mode
# Options: advisory, enforcing, permissive
mode = enforcing

# Enable enforcement modules (all require root)
network_enforcement = true
usb_enforcement = true
process_enforcement = true

# Protection persistence - rules survive daemon restarts
# CRITICAL: Prevents security gaps during daemon restart/crash
persist_protections = true

# Fail-closed behavior - if enforcement fails, enter LOCKDOWN
fail_closed = true

[network]
# Network enforcement via iptables/nftables
# Requires: root, iptables or nftables installed
enabled = true

# Firewall backend preference (auto-detects if not specified)
# Options: auto, iptables, nftables
backend = auto

# VPN interfaces allowed in TRUSTED mode
vpn_interfaces = tun0,wg0,ppp0,tailscale0

# Log blocked connections
log_blocked = true

# Emergency lockdown blocks ALL traffic including loopback
lockdown_blocks_loopback = true

[usb]
# USB enforcement via udev rules
# Requires: root, udevadm installed
enabled = true

# Device classes to always allow (comma-separated)
# 03 = HID (keyboard/mouse), 09 = Hub
essential_classes = 03,09

# Block USB mass storage in these modes (comma-separated)
block_storage_modes = trusted,airgap,coldroom,lockdown

# Block ALL non-essential USB in these modes
block_all_modes = coldroom,lockdown

# Eject existing storage on mode transition
eject_on_transition = true

# Log all USB events
log_usb_events = true

[process]
# Process enforcement via seccomp-bpf and containers
# Requires: root, seccomp support in kernel
enabled = true

# Seccomp profile directory
profile_dir = /etc/boundary-daemon/seccomp

# Container runtime preference (for workload isolation)
# Options: auto, podman, docker, none
container_runtime = auto

# Block dangerous syscalls in these modes
syscall_filtering_modes = restricted,trusted,airgap,coldroom,lockdown

# Block network syscalls in these modes
block_network_syscalls_modes = airgap,coldroom,lockdown

# Enable internal watchdog thread
enable_watchdog = true

# Terminate suspicious processes on LOCKDOWN
terminate_on_lockdown = true

[persistence]
# Protection persistence settings
# Ensures rules survive daemon restarts/crashes

# Persistence file location
state_file = /var/lib/boundary-daemon/protection_state.json

# Re-apply protections on startup
reapply_on_startup = true

# Sticky protections require authentication to remove
sticky_protections = true

# Emergency protections require admin override
emergency_requires_admin = true

# Cleanup policy on graceful shutdown
# Options: preserve, cleanup_non_sticky, cleanup_all
shutdown_policy = preserve

[watchdog]
# External watchdog integration
# Monitors daemon health and triggers lockdown on failure

# Enable systemd watchdog integration
systemd_watchdog = true

# Heartbeat interval (seconds)
heartbeat_interval = 5

# Missed heartbeats before lockdown
missed_heartbeats_threshold = 3

# Hardware watchdog device (optional)
# Set to /dev/watchdog for hardware watchdog support
hardware_watchdog_device =

# Lockdown on daemon crash
lockdown_on_crash = true

[logging]
# Enforcement-specific logging

# Log all enforcement actions
log_actions = true

# Log to syslog in addition to file
syslog_enabled = true

# Syslog facility
syslog_facility = auth

# Log prefix for firewall rules
firewall_log_prefix = BOUNDARY

# Include enforcement status in audit events
audit_enforcement = true

[ebpf]
# Phase 2: eBPF Real-Time Monitoring
# Eliminates the ~1 second race condition from polling-based detection
# Requires: Linux kernel 4.15+, BCC (BPF Compiler Collection), root

# Enable eBPF monitoring
enabled = true

# Monitor network syscalls in real-time
# Captures: socket(), connect(), bind(), sendto(), accept()
network_monitoring = true

# Monitor process execution in real-time
# Captures: execve(), fork(), exit()
process_monitoring = true

# Monitor USB events via eBPF (experimental)
# Note: USB monitoring via eBPF is complex; udev is more reliable
usb_monitoring = false

# Action to take on suspicious network activity
# Options: log, alert, block (block requires BPF_PROG_TYPE_LSM)
network_violation_action = alert

# Action to take on suspicious process execution
process_violation_action = alert

# UIDs to ignore (comma-separated)
# Default: 0 (root) to avoid noise from system processes
ignored_uids = 0

# PIDs to ignore (comma-separated, usually set dynamically)
ignored_pids =

# Maximum events per second before throttling (prevents log spam)
max_events_per_second = 10000

# Event buffer size for recent events
event_buffer_size = 1000

# Enable real-time lockdown triggers
# When enabled, certain eBPF events can trigger immediate lockdown
realtime_lockdown = true

# Modes where eBPF should trigger alerts on any network activity
alert_on_network_modes = airgap,coldroom,lockdown

# Modes where eBPF should trigger alerts on suspicious processes
alert_on_process_modes = coldroom,lockdown
